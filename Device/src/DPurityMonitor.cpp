
/*  Â© Copyright CERN, 2015. All rights not expressly granted are reserved.
        
    The stub of this file was generated by Quasar (additional info: using transform designToDeviceBody.xslt) 
    on 2020-03-04T17:41:11.827Z
    
    Quasar is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public Licence as published by
    the Free Software Foundation, either version 3 of the Licence.
    Quasar is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public Licence for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with Quasar.  If not, see <http://www.gnu.org/licenses/>.
    
    
    
 */




#include <Configuration.hxx>

#include <DPurityMonitor.h>
#include <ASPurityMonitor.h>

#include <stdio.h>
#include <stdlib.h>
#include <ctime>



namespace Device
{




  // 1111111111111111111111111111111111111111111111111111111111111111111111111
  // 1     GENERATED CODE STARTS HERE AND FINISHES AT SECTION 2              1
  // 1     Users don't modify this code!!!!                                  1
  // 1     If you modify this code you may start a fire or a flood somewhere,1
  // 1     and some human being may possible cease to exist. You don't want  1
  // 1     to be charged with that!                                          1 
  // 1111111111111111111111111111111111111111111111111111111111111111111111111






  // 2222222222222222222222222222222222222222222222222222222222222222222222222
  // 2     SEMI CUSTOM CODE STARTS HERE AND FINISHES AT SECTION 3            2
  // 2     (code for which only stubs were generated automatically)          2
  // 2     You should add the implementation but dont alter the headers      2
  // 2     (apart from constructor, in which you should complete initializati2
  // 2     on list)                                                          2 
  // 2222222222222222222222222222222222222222222222222222222222222222222222222

  /* sample ctr */
  DPurityMonitor::DPurityMonitor (const Configuration::PurityMonitor & config,
				  Parent_DPurityMonitor *
				  parent):Base_DPurityMonitor (config, parent)
    /* fill up constructor initialization list here */
  {
    /* fill up constructor body here */
  }

  /* sample dtr */
  DPurityMonitor::~DPurityMonitor ()
  {
  }

  /* delegators for cachevariables and externalvariables */

  /* Note: never directly call this function. */

  UaStatus DPurityMonitor::writeRunningConfiguration (const OpcUa_Int16 & v)
  {

	if (v < 0)
		return OpcUa_BadOutOfRange;
	if (v > 2)
		return OpcUa_BadOutOfRange;

    return OpcUa_Good;
  }

  /* Note: never directly call this function. */

  UaStatus DPurityMonitor::writeTakeData (const OpcUa_Int16 & v)
  {
   if (v == 0 || v == 1)
		return OpcUa_Good;

   return OpcUa_BadOutOfRange;
  }

  /* Note: never directly call this function. */

  UaStatus DPurityMonitor::writeDoAnalysis (const OpcUa_Int16 & v)
  {
	  if (v == 0 || v == 1)
		  return OpcUa_Good;

	  return OpcUa_BadOutOfRange;

  }


  // 3333333333333333333333333333333333333333333333333333333333333333333333333
  // 3     FULLY CUSTOM CODE STARTS HERE                                     3
  // 3     Below you put bodies for custom methods defined for this class.   3
  // 3     You can do whatever you want, but please be decent.               3
  // 3333333333333333333333333333333333333333333333333333333333333333333333333

  void DPurityMonitor::update()
  {

	  if ( getAddressSpaceLink()->getBusy()== 0 ) {

		  getAddressSpaceLink()->setBusy(1, OpcUa_Good);

		  LOG(Log::INF) << "Is purity monitor busy = " <<  getAddressSpaceLink()->getBusy();

		  UaStatus status;

		  if ( getAddressSpaceLink()->getTakeData() == 1 ){

			  LOG(Log::INF) << "Taking data with configuration " <<  getAddressSpaceLink()->getRunningConfiguration();

			  switch(getAddressSpaceLink()->getRunningConfiguration()){

			  case 0:
				  LOG(Log::INF) << "Taking software triggers.";
				  status = executeCommand("takeSoftwareTriggers");
				  LOG(Log::INF) << "Finished with status " << status;
				  break;

			  case 1:
				  LOG(Log::INF) << "Taking lamp only run.";
				  status = executeCommand("takeLamp");
				  LOG(Log::INF) << "Finished with status " << status;
				  break;

			  case 2:
				  LOG(Log::INF) << "Taking run with field configuration 40.20.60 V/cm.";
				  status = executeCommand("takeLowFields20");
				  LOG(Log::INF) << "Finished with status " << status;
				  break;

			  case 3:
				  LOG(Log::INF) << "Taking run with field configuration 60.30.90 V/cm.";
				  status = executeCommand("takeLowFields30");
				  LOG(Log::INF) << "Finished with status " << status;
				  break;

			  }


			  LOG(Log::INF) << "I have finished taking data with configuration " <<  getAddressSpaceLink()->getRunningConfiguration();

			  getAddressSpaceLink()->setTakeData(0, OpcUa_Good);
		  }

		  else if ( getAddressSpaceLink()->getDoAnalysis() == 1 ){

			  LOG(Log::INF) << "Doing the analysis" ;

			  status = executeCommand("doEverythingForMe");
			  LOG(Log::INF) << "Finished with status " << status;

			  getAddressSpaceLink()->setDoAnalysis(0, OpcUa_Good);

		  }

		  getAddressSpaceLink()->setBusy(0, OpcUa_Good);

	  } else {

		  // if the server is busy you shouldn't be allowed to do anything

		  getAddressSpaceLink()->setTakeData(0, OpcUa_Good);

		  getAddressSpaceLink()->setDoAnalysis(0, OpcUa_Good);

	  }

  }



UaStatus DPurityMonitor::executeCommand(char *cmd){

	  char outfile[80], infile[80];
	  sprintf(infile,"/home/lindac/DUNE/takeLifetimeData/%s.sh", cmd);

	  time_t rawtime;
	  struct tm * timeinfo;
	  char timeaschar[80];

	  time (&rawtime);
	  timeinfo = localtime(&rawtime);

	  strftime(timeaschar,sizeof(timeaschar),"%Y.%m.%d_%H.%M",timeinfo);

	  sprintf(outfile,"/data/PurityMonitor/Filling/logs/%s_%s.log", cmd, timeaschar);

      FILE* pipe = popen(infile, "r");
      if (!pipe) return OpcUa_Bad;
      char buffer[128];
      std::string result = "";
      while(!feof(pipe)) {
          if(fgets(buffer, 128, pipe) != NULL)
              result = result + buffer;
      }
      pclose(pipe);

      FILE *flog = fopen(outfile, "w");

      fprintf(flog,"%s",result.c_str());
      fclose(flog);

      LOG(Log::INF) << "Log file written in " << outfile ;
      return OpcUa_Good;
  }


}
