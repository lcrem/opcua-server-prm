
/*  Â© Copyright CERN, 2015. All rights not expressly granted are reserved.
    Authors(from Quasar team): Piotr Nikiel
        
    This file is part of Quasar.
   
    Quasar is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public Licence as published by
    the Free Software Foundation, either version 3 of the Licence.
    Quasar is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public Licence for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with Quasar.  If not, see <http://www.gnu.org/licenses/>.
    
    This file was completely generated by Quasar (additional info: using transform designToDeviceBaseBody.xslt) 
    on 2020-02-26T11:25:33.087Z
 */




#include <Configuration.hxx>



#include <Base_DMotor.h>

#include <DTemperatureProbe.h>

#include <DAirFlowProbe.h>

#include <Base_DController.h>

#include <DMotor.h>

#include <Base_DTemperatureProbe.h>

#include <Base_DAirFlowProbe.h>




namespace Device
{



  void Base_DMotor::linkAddressSpace (AddressSpace::ASMotor *
				      addressSpaceLink,
				      const std::string & stringAddress)
  {
    if (m_addressSpaceLink != 0)
      {
	/* signalize nice error from here. */
	abort ();
      }
    else
        m_addressSpaceLink = addressSpaceLink;
    m_stringAddress.assign (stringAddress);
  }

  AddressSpace::ASMotor * Base_DMotor::getAddressSpaceLink ()const
  {
    if (m_addressSpaceLink)
      return m_addressSpaceLink;
    else
      throw std::logic_error ("m_addressSpaceLink is nullptr! at:" +
			      m_stringAddress);
  }

  /* add/remove */

  void Base_DMotor::add (DTemperatureProbe * device)
  {
    m_TemperatureProbes.push_back (device);
  }

  void Base_DMotor::add (DAirFlowProbe * device)
  {
    m_AirFlowProbes.push_back (device);
  }


  //! Disconnects AddressSpace part from the Device logic, and does the same for all children
  //! Returns number of unlinked objects including self
  unsigned int Base_DMotor::unlinkAllChildren ()
  {
    unsigned int objectCounter = 1;	// 1 is for self
    m_addressSpaceLink = 0;
    /* Fill up: call unlinkAllChildren on all children */

  for (DTemperatureProbe * d:m_TemperatureProbes)
      {
	objectCounter += d->unlinkAllChildren ();
      }

  for (DAirFlowProbe * d:m_AirFlowProbes)
      {
	objectCounter += d->unlinkAllChildren ();
      }

    return objectCounter;

  }


  /* find methods for children */






  /* Constructor */
Base_DMotor::Base_DMotor (const Configuration::Motor & config, Parent_DMotor * parent):

  m_parent (parent),
    m_addressSpaceLink (0),
    m_stringAddress ("**NB**"), m_identifier (config.identifier ())
  {

  }

  Base_DMotor::~Base_DMotor ()
  {
    /* remove children */

  for (DTemperatureProbe * d:m_TemperatureProbes)
      {
	delete d;
      }

  for (DAirFlowProbe * d:m_AirFlowProbes)
      {
	delete d;
      }

  }



  std::list < DMotor * >Base_DMotor::s_orphanedObjects;


  void Base_DController::linkAddressSpace (AddressSpace::ASController *
					   addressSpaceLink,
					   const std::string & stringAddress)
  {
    if (m_addressSpaceLink != 0)
      {
	/* signalize nice error from here. */
	abort ();
      }
    else
      m_addressSpaceLink = addressSpaceLink;
    m_stringAddress.assign (stringAddress);
  }

  AddressSpace::ASController * Base_DController::getAddressSpaceLink ()const
  {
    if (m_addressSpaceLink)
      return m_addressSpaceLink;
    else
      throw std::logic_error ("m_addressSpaceLink is nullptr! at:" +
			      m_stringAddress);
  }

  /* add/remove */

  void Base_DController::add (DMotor * device)
  {
    m_Motors.push_back (device);
  }


  //! Disconnects AddressSpace part from the Device logic, and does the same for all children
  //! Returns number of unlinked objects including self
  unsigned int Base_DController::unlinkAllChildren ()
  {
    unsigned int objectCounter = 1;	// 1 is for self
    m_addressSpaceLink = 0;
    /* Fill up: call unlinkAllChildren on all children */

  for (DMotor * d:m_Motors)
      {
	objectCounter += d->unlinkAllChildren ();
      }

    return objectCounter;

  }


  /* find methods for children */






  /* Constructor */
Base_DController::Base_DController (const Configuration::Controller & config, Parent_DController * parent):

  m_parent (parent),
    m_addressSpaceLink (0), m_stringAddress ("**NB**")
  {

  }

  Base_DController::~Base_DController ()
  {
    /* remove children */

  for (DMotor * d:m_Motors)
      {
	delete d;
      }

  }



  std::list < DController * >Base_DController::s_orphanedObjects;


  void Base_DTemperatureProbe::linkAddressSpace (AddressSpace::
						 ASTemperatureProbe *
						 addressSpaceLink,
						 const std::
						 string & stringAddress)
  {
    if (m_addressSpaceLink != 0)
      {
	/* signalize nice error from here. */
	abort ();
      }
    else
      m_addressSpaceLink = addressSpaceLink;
    m_stringAddress.assign (stringAddress);
  }

  AddressSpace::ASTemperatureProbe *
    Base_DTemperatureProbe::getAddressSpaceLink ()const
  {
    if (m_addressSpaceLink)
      return m_addressSpaceLink;
    else
      throw std::logic_error ("m_addressSpaceLink is nullptr! at:" +
			      m_stringAddress);
  }

  /* add/remove */


  //! Disconnects AddressSpace part from the Device logic, and does the same for all children
  //! Returns number of unlinked objects including self
  unsigned int Base_DTemperatureProbe::unlinkAllChildren ()
  {
    unsigned int objectCounter = 1;	// 1 is for self
    m_addressSpaceLink = 0;
    /* Fill up: call unlinkAllChildren on all children */

    return objectCounter;

  }


  /* find methods for children */






  /* Constructor */
Base_DTemperatureProbe::Base_DTemperatureProbe (const Configuration::TemperatureProbe & config, Parent_DTemperatureProbe * parent):

  m_parent (parent),
    m_addressSpaceLink (0), m_stringAddress ("**NB**")
  {

  }

  Base_DTemperatureProbe::~Base_DTemperatureProbe ()
  {
    /* remove children */

  }



  std::list < DTemperatureProbe * >Base_DTemperatureProbe::s_orphanedObjects;


  void Base_DAirFlowProbe::linkAddressSpace (AddressSpace::ASAirFlowProbe *
					     addressSpaceLink,
					     const std::
					     string & stringAddress)
  {
    if (m_addressSpaceLink != 0)
      {
	/* signalize nice error from here. */
	abort ();
      }
    else
      m_addressSpaceLink = addressSpaceLink;
    m_stringAddress.assign (stringAddress);
  }

  AddressSpace::ASAirFlowProbe * Base_DAirFlowProbe::getAddressSpaceLink ()const
  {
    if (m_addressSpaceLink)
      return m_addressSpaceLink;
    else
      throw std::logic_error ("m_addressSpaceLink is nullptr! at:" +
			      m_stringAddress);
  }

  /* add/remove */


  //! Disconnects AddressSpace part from the Device logic, and does the same for all children
  //! Returns number of unlinked objects including self
  unsigned int Base_DAirFlowProbe::unlinkAllChildren ()
  {
    unsigned int objectCounter = 1;	// 1 is for self
    m_addressSpaceLink = 0;
    /* Fill up: call unlinkAllChildren on all children */

    return objectCounter;

  }


  /* find methods for children */






  /* Constructor */
Base_DAirFlowProbe::Base_DAirFlowProbe (const Configuration::AirFlowProbe & config, Parent_DAirFlowProbe * parent):

  m_parent (parent),
    m_addressSpaceLink (0), m_stringAddress ("**NB**")
  {

  }

  Base_DAirFlowProbe::~Base_DAirFlowProbe ()
  {
    /* remove children */

  }



  std::list < DAirFlowProbe * >Base_DAirFlowProbe::s_orphanedObjects;



}
