
/*  Â© Copyright CERN, 2015. All rights not expressly granted are reserved.
    Authors(from Quasar team): Piotr Nikiel
        
    This file is part of Quasar.
   
    Quasar is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public Licence as published by
    the Free Software Foundation, either version 3 of the Licence.
    Quasar is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public Licence for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with Quasar.  If not, see <http://www.gnu.org/licenses/>.
    
    This file was completely generated by Quasar (additional info: using transform designToClassBody.xslt) 
    on 2020-02-24T16:26:19.409Z
 */


#include <iostream>
#include <climits>

#include <boost/lexical_cast.hpp>

#include <ArrayTools.h>
#include <Utils.h>
#include <ChangeNotifyingVariable.h>
#include <CalculatedVariablesEngine.h>

#include <SourceVariables.h>



#include <ASMotor.h>


#include <DMotor.h>


namespace AddressSpace
{



/*ctr*/
  ASMotor::ASMotor (UaNodeId parentNodeId,
		    const UaNodeId & typeNodeId,
		    ASNodeManager * nm,
		    const Configuration::Motor & config):OpcUa::
    BaseObjectType (
			 /*nodeId */
			 nm->makeChildNodeId (parentNodeId,
					      (config.name ()).c_str ()),
    /*name */ (config.name ()).c_str (), nm->getNameSpaceIndex (), nm),
    m_typeNodeId (typeNodeId)
   , m_rotationalSpeed (new
			ChangeNotifyingVariable (nm->
						 makeChildNodeId (this->
								  nodeId (),
								  UaString
								  ("rotationalSpeed")),
						 UaString ("rotationalSpeed"),
						 nm->getNameSpaceIndex (),
						 UaVariant (),
						 OpcUa_AccessLevels_CurrentRead,
						 nm)),
    m_rotationalSpeedSetPoint (new
			       ChangeNotifyingVariable (nm->
							makeChildNodeId
							(this->nodeId (),
							 UaString
							 ("rotationalSpeedSetPoint")),
							UaString
							("rotationalSpeedSetPoint"),
							nm->
							getNameSpaceIndex (),
							UaVariant (),
							OpcUa_AccessLevels_CurrentReadOrWrite,
							nm)), m_deviceLink (0)
  {

    UaStatus s;
    UaVariant v;


      s = nm->addNodeAndReference (parentNodeId, this, OpcUaId_HasComponent);
    if (!s.isGood ())
      {
	LOG (Log::ERR) << "While addNodeAndReference from " << parentNodeId.
	  toString ().toUtf8 () << " to " << this->nodeId ().toString ().
	  toUtf8 () << " : ";
	ASSERT_GOOD (s);
      }



    v.clear ();

    m_rotationalSpeed->setValue ( /*pSession */ 0, UaDataValue (UaVariant (v),
								OpcUa_BadWaitingForInitialData,
								UaDateTime::
								now (),
								UaDateTime::
								now ()),
				 /*check access level */ OpcUa_False);

    s = nm->addNodeAndReference (this,
				 m_rotationalSpeed, OpcUaId_HasComponent);
    if (!s.isGood ())
      {
	std::cout << "While addNodeAndReference from " << this->nodeId ().
	  toString ().toUtf8 () << " to " << m_rotationalSpeed->nodeId ().
	  toString ().toUtf8 () << " : " << std::endl;
	ASSERT_GOOD (s);
      }



    CalculatedVariables::Engine::
      registerVariableForCalculatedVariables (m_rotationalSpeed);

    v.setDouble (0);

    m_rotationalSpeedSetPoint->setValue ( /*pSession */ 0,
					 UaDataValue (UaVariant (v),
						      OpcUa_Good,
						      UaDateTime::now (),
						      UaDateTime::now ()),
					 /*check access level */ OpcUa_False);

    s = nm->addNodeAndReference (this,
				 m_rotationalSpeedSetPoint,
				 OpcUaId_HasComponent);
    if (!s.isGood ())
      {
	std::cout << "While addNodeAndReference from " << this->nodeId ().
	  toString ().toUtf8 () << " to " << m_rotationalSpeedSetPoint->
	  nodeId ().toString ().toUtf8 () << " : " << std::endl;
	ASSERT_GOOD (s);
      }



    CalculatedVariables::Engine::
      registerVariableForCalculatedVariables (m_rotationalSpeedSetPoint);


  }





  ASMotor::~ASMotor ()
  {

    if (m_deviceLink != 0)
      {
	LOG (Log::ERR) << "deviceLink not zero!!";
      }

  }




/* generate setters and getters (if requested) */


  UaStatus ASMotor::setRotationalSpeed (const OpcUa_Double value,
					OpcUa_StatusCode statusCode,
					const UaDateTime & srcTime)
  {

    UaVariant v;

    v.setDouble (value);

    return m_rotationalSpeed->setValue (0,
					UaDataValue (v, statusCode, srcTime,
						     UaDateTime::now ()),
					/*check access */ OpcUa_False);

  }


  UaStatus ASMotor::getRotationalSpeed (OpcUa_Double & r) const
  {
    UaVariant v (*(m_rotationalSpeed->value ( /*session */ 0).value ()));
      return v.toDouble (r);
  }

  /* null-setter (possible because nullPolicy='nullAllowed') */
  UaStatus ASMotor::setNullRotationalSpeed (OpcUa_StatusCode statusCode,
					    const UaDateTime & srcTime)
  {
    UaVariant v;

    return m_rotationalSpeed->setValue (0,
					UaDataValue (v, statusCode, srcTime,
						     UaDateTime::now ()),
					/*check access */ OpcUa_False);

  }


  UaStatus ASMotor::setRotationalSpeedSetPoint (const OpcUa_Double value,
						OpcUa_StatusCode statusCode,
						const UaDateTime & srcTime)
  {

    UaVariant v;

    v.setDouble (value);

    return m_rotationalSpeedSetPoint->setValue (0,
						UaDataValue (v, statusCode,
							     srcTime,
							     UaDateTime::
							     now ()),
						/*check access */
						OpcUa_False);

  }


  UaStatus ASMotor::getRotationalSpeedSetPoint (OpcUa_Double & r) const
  {
    UaVariant
      v (*(m_rotationalSpeedSetPoint->value ( /*session */ 0).value ()));
      return v.toDouble (r);
  }

  /* null-setter (possible because nullPolicy='nullAllowed') */
  UaStatus ASMotor::
    setNullRotationalSpeedSetPoint (OpcUa_StatusCode statusCode,
				    const UaDateTime & srcTime)
  {
    UaVariant v;

    return m_rotationalSpeedSetPoint->setValue (0,
						UaDataValue (v, statusCode,
							     srcTime,
							     UaDateTime::
							     now ()),
						/*check access */
						OpcUa_False);

  }





/* generate delegates (if requested) */

/* NOTE: This function is not intended to be used by human being. */
  UaStatus
    ASMotor::writeRotationalSpeedSetPoint (Session * pSession,
					   const UaDataValue & dataValue,
					   OpcUa_Boolean checkAccessLevel)
  {


    /* ensure that data type passed by OPC UA client matches specification */
    UaVariant v (*dataValue.value ());
    if (v.type () != OpcUaType_Double)
      {

	if (v.type () != OpcUaType_Null)
	  return OpcUa_BadDataEncodingInvalid;	// now we know it is neither the intended datatype nor NULL

      }

    return OpcUa_Good;


  }





/* generate device logic link */


  void ASMotor::linkDevice (Device::DMotor * deviceLink)
  {
    if (m_deviceLink != 0)
      {
	/* This is an error -- device can be linked at most in the object's lifetime. */
	//TODO After error handling is discussed, abort in smarter way
	abort ();

      }
    else
      m_deviceLink = deviceLink;
  }


  void ASMotor::unlinkDevice ()
  {
    m_deviceLink = 0;
  }


}
