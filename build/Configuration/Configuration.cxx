// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "Configuration.hxx"

namespace Configuration
{
  // StandardMetaData
  // 

  const StandardMetaData::Quasar_optional& StandardMetaData::
  Quasar () const
  {
    return this->Quasar_;
  }

  StandardMetaData::Quasar_optional& StandardMetaData::
  Quasar ()
  {
    return this->Quasar_;
  }

  void StandardMetaData::
  Quasar (const Quasar_type& x)
  {
    this->Quasar_.set (x);
  }

  void StandardMetaData::
  Quasar (const Quasar_optional& x)
  {
    this->Quasar_ = x;
  }

  void StandardMetaData::
  Quasar (::std::unique_ptr< Quasar_type > x)
  {
    this->Quasar_.set (std::move (x));
  }

  const StandardMetaData::Log_optional& StandardMetaData::
  Log () const
  {
    return this->Log_;
  }

  StandardMetaData::Log_optional& StandardMetaData::
  Log ()
  {
    return this->Log_;
  }

  void StandardMetaData::
  Log (const Log_type& x)
  {
    this->Log_.set (x);
  }

  void StandardMetaData::
  Log (const Log_optional& x)
  {
    this->Log_ = x;
  }

  void StandardMetaData::
  Log (::std::unique_ptr< Log_type > x)
  {
    this->Log_.set (std::move (x));
  }

  const StandardMetaData::SourceVariableThreadPool_optional& StandardMetaData::
  SourceVariableThreadPool () const
  {
    return this->SourceVariableThreadPool_;
  }

  StandardMetaData::SourceVariableThreadPool_optional& StandardMetaData::
  SourceVariableThreadPool ()
  {
    return this->SourceVariableThreadPool_;
  }

  void StandardMetaData::
  SourceVariableThreadPool (const SourceVariableThreadPool_type& x)
  {
    this->SourceVariableThreadPool_.set (x);
  }

  void StandardMetaData::
  SourceVariableThreadPool (const SourceVariableThreadPool_optional& x)
  {
    this->SourceVariableThreadPool_ = x;
  }

  void StandardMetaData::
  SourceVariableThreadPool (::std::unique_ptr< SourceVariableThreadPool_type > x)
  {
    this->SourceVariableThreadPool_.set (std::move (x));
  }

  const StandardMetaData::Server_optional& StandardMetaData::
  Server () const
  {
    return this->Server_;
  }

  StandardMetaData::Server_optional& StandardMetaData::
  Server ()
  {
    return this->Server_;
  }

  void StandardMetaData::
  Server (const Server_type& x)
  {
    this->Server_.set (x);
  }

  void StandardMetaData::
  Server (const Server_optional& x)
  {
    this->Server_ = x;
  }

  void StandardMetaData::
  Server (::std::unique_ptr< Server_type > x)
  {
    this->Server_.set (std::move (x));
  }


  // Log
  // 

  const Log::GeneralLogLevel_optional& Log::
  GeneralLogLevel () const
  {
    return this->GeneralLogLevel_;
  }

  Log::GeneralLogLevel_optional& Log::
  GeneralLogLevel ()
  {
    return this->GeneralLogLevel_;
  }

  void Log::
  GeneralLogLevel (const GeneralLogLevel_type& x)
  {
    this->GeneralLogLevel_.set (x);
  }

  void Log::
  GeneralLogLevel (const GeneralLogLevel_optional& x)
  {
    this->GeneralLogLevel_ = x;
  }

  void Log::
  GeneralLogLevel (::std::unique_ptr< GeneralLogLevel_type > x)
  {
    this->GeneralLogLevel_.set (std::move (x));
  }

  const Log::ComponentLogLevels_optional& Log::
  ComponentLogLevels () const
  {
    return this->ComponentLogLevels_;
  }

  Log::ComponentLogLevels_optional& Log::
  ComponentLogLevels ()
  {
    return this->ComponentLogLevels_;
  }

  void Log::
  ComponentLogLevels (const ComponentLogLevels_type& x)
  {
    this->ComponentLogLevels_.set (x);
  }

  void Log::
  ComponentLogLevels (const ComponentLogLevels_optional& x)
  {
    this->ComponentLogLevels_ = x;
  }

  void Log::
  ComponentLogLevels (::std::unique_ptr< ComponentLogLevels_type > x)
  {
    this->ComponentLogLevels_.set (std::move (x));
  }


  // GeneralLogLevel
  // 

  const GeneralLogLevel::logLevel_type& GeneralLogLevel::
  logLevel () const
  {
    return this->logLevel_.get ();
  }

  GeneralLogLevel::logLevel_type& GeneralLogLevel::
  logLevel ()
  {
    return this->logLevel_.get ();
  }

  void GeneralLogLevel::
  logLevel (const logLevel_type& x)
  {
    this->logLevel_.set (x);
  }

  void GeneralLogLevel::
  logLevel (::std::unique_ptr< logLevel_type > x)
  {
    this->logLevel_.set (std::move (x));
  }


  // ComponentLogLevels
  // 

  const ComponentLogLevels::ComponentLogLevel_sequence& ComponentLogLevels::
  ComponentLogLevel () const
  {
    return this->ComponentLogLevel_;
  }

  ComponentLogLevels::ComponentLogLevel_sequence& ComponentLogLevels::
  ComponentLogLevel ()
  {
    return this->ComponentLogLevel_;
  }

  void ComponentLogLevels::
  ComponentLogLevel (const ComponentLogLevel_sequence& s)
  {
    this->ComponentLogLevel_ = s;
  }


  // ComponentLogLevel
  // 

  const ComponentLogLevel::componentName_type& ComponentLogLevel::
  componentName () const
  {
    return this->componentName_.get ();
  }

  ComponentLogLevel::componentName_type& ComponentLogLevel::
  componentName ()
  {
    return this->componentName_.get ();
  }

  void ComponentLogLevel::
  componentName (const componentName_type& x)
  {
    this->componentName_.set (x);
  }

  void ComponentLogLevel::
  componentName (::std::unique_ptr< componentName_type > x)
  {
    this->componentName_.set (std::move (x));
  }

  const ComponentLogLevel::logLevel_type& ComponentLogLevel::
  logLevel () const
  {
    return this->logLevel_.get ();
  }

  ComponentLogLevel::logLevel_type& ComponentLogLevel::
  logLevel ()
  {
    return this->logLevel_.get ();
  }

  void ComponentLogLevel::
  logLevel (const logLevel_type& x)
  {
    this->logLevel_.set (x);
  }

  void ComponentLogLevel::
  logLevel (::std::unique_ptr< logLevel_type > x)
  {
    this->logLevel_.set (std::move (x));
  }


  // SourceVariableThreadPool
  // 

  const SourceVariableThreadPool::minThreads_type& SourceVariableThreadPool::
  minThreads () const
  {
    return this->minThreads_.get ();
  }

  SourceVariableThreadPool::minThreads_type& SourceVariableThreadPool::
  minThreads ()
  {
    return this->minThreads_.get ();
  }

  void SourceVariableThreadPool::
  minThreads (const minThreads_type& x)
  {
    this->minThreads_.set (x);
  }

  const SourceVariableThreadPool::maxThreads_type& SourceVariableThreadPool::
  maxThreads () const
  {
    return this->maxThreads_.get ();
  }

  SourceVariableThreadPool::maxThreads_type& SourceVariableThreadPool::
  maxThreads ()
  {
    return this->maxThreads_.get ();
  }

  void SourceVariableThreadPool::
  maxThreads (const maxThreads_type& x)
  {
    this->maxThreads_.set (x);
  }

  const SourceVariableThreadPool::maxJobs_type& SourceVariableThreadPool::
  maxJobs () const
  {
    return this->maxJobs_.get ();
  }

  SourceVariableThreadPool::maxJobs_type& SourceVariableThreadPool::
  maxJobs ()
  {
    return this->maxJobs_.get ();
  }

  void SourceVariableThreadPool::
  maxJobs (const maxJobs_type& x)
  {
    this->maxJobs_.set (x);
  }


  // logLevelIdentifier
  // 

  logLevelIdentifier::
  logLevelIdentifier (value v)
  : ::xml_schema::string (_xsd_logLevelIdentifier_literals_[v])
  {
  }

  logLevelIdentifier::
  logLevelIdentifier (const char* v)
  : ::xml_schema::string (v)
  {
  }

  logLevelIdentifier::
  logLevelIdentifier (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  logLevelIdentifier::
  logLevelIdentifier (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  logLevelIdentifier::
  logLevelIdentifier (const logLevelIdentifier& v,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  logLevelIdentifier& logLevelIdentifier::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_logLevelIdentifier_literals_[v]);

    return *this;
  }


  // Quasar
  // 


  // Server
  // 


  // ObjectName
  // 


  // CalculatedVariable
  // 

  const CalculatedVariable::name_type& CalculatedVariable::
  name () const
  {
    return this->name_.get ();
  }

  CalculatedVariable::name_type& CalculatedVariable::
  name ()
  {
    return this->name_.get ();
  }

  void CalculatedVariable::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void CalculatedVariable::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }

  const CalculatedVariable::value_type& CalculatedVariable::
  value () const
  {
    return this->value_.get ();
  }

  CalculatedVariable::value_type& CalculatedVariable::
  value ()
  {
    return this->value_.get ();
  }

  void CalculatedVariable::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void CalculatedVariable::
  value (::std::unique_ptr< value_type > x)
  {
    this->value_.set (std::move (x));
  }

  const CalculatedVariable::initialValue_optional& CalculatedVariable::
  initialValue () const
  {
    return this->initialValue_;
  }

  CalculatedVariable::initialValue_optional& CalculatedVariable::
  initialValue ()
  {
    return this->initialValue_;
  }

  void CalculatedVariable::
  initialValue (const initialValue_type& x)
  {
    this->initialValue_.set (x);
  }

  void CalculatedVariable::
  initialValue (const initialValue_optional& x)
  {
    this->initialValue_ = x;
  }

  const CalculatedVariable::isBoolean_type& CalculatedVariable::
  isBoolean () const
  {
    return this->isBoolean_.get ();
  }

  CalculatedVariable::isBoolean_type& CalculatedVariable::
  isBoolean ()
  {
    return this->isBoolean_.get ();
  }

  void CalculatedVariable::
  isBoolean (const isBoolean_type& x)
  {
    this->isBoolean_.set (x);
  }

  CalculatedVariable::isBoolean_type CalculatedVariable::
  isBoolean_default_value ()
  {
    return isBoolean_type (false);
  }

  const CalculatedVariable::status_optional& CalculatedVariable::
  status () const
  {
    return this->status_;
  }

  CalculatedVariable::status_optional& CalculatedVariable::
  status ()
  {
    return this->status_;
  }

  void CalculatedVariable::
  status (const status_type& x)
  {
    this->status_.set (x);
  }

  void CalculatedVariable::
  status (const status_optional& x)
  {
    this->status_ = x;
  }

  void CalculatedVariable::
  status (::std::unique_ptr< status_type > x)
  {
    this->status_.set (std::move (x));
  }


  // CalculatedVariableGenericFormula
  // 

  const CalculatedVariableGenericFormula::name_type& CalculatedVariableGenericFormula::
  name () const
  {
    return this->name_.get ();
  }

  CalculatedVariableGenericFormula::name_type& CalculatedVariableGenericFormula::
  name ()
  {
    return this->name_.get ();
  }

  void CalculatedVariableGenericFormula::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void CalculatedVariableGenericFormula::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }

  const CalculatedVariableGenericFormula::formula_type& CalculatedVariableGenericFormula::
  formula () const
  {
    return this->formula_.get ();
  }

  CalculatedVariableGenericFormula::formula_type& CalculatedVariableGenericFormula::
  formula ()
  {
    return this->formula_.get ();
  }

  void CalculatedVariableGenericFormula::
  formula (const formula_type& x)
  {
    this->formula_.set (x);
  }

  void CalculatedVariableGenericFormula::
  formula (::std::unique_ptr< formula_type > x)
  {
    this->formula_.set (std::move (x));
  }


  // Motor
  // 

  const Motor::CalculatedVariable_sequence& Motor::
  CalculatedVariable () const
  {
    return this->CalculatedVariable_;
  }

  Motor::CalculatedVariable_sequence& Motor::
  CalculatedVariable ()
  {
    return this->CalculatedVariable_;
  }

  void Motor::
  CalculatedVariable (const CalculatedVariable_sequence& s)
  {
    this->CalculatedVariable_ = s;
  }

  const Motor::name_type& Motor::
  name () const
  {
    return this->name_.get ();
  }

  Motor::name_type& Motor::
  name ()
  {
    return this->name_.get ();
  }

  void Motor::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void Motor::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }


  // Configuration
  // 

  const Configuration::StandardMetaData_optional& Configuration::
  StandardMetaData () const
  {
    return this->StandardMetaData_;
  }

  Configuration::StandardMetaData_optional& Configuration::
  StandardMetaData ()
  {
    return this->StandardMetaData_;
  }

  void Configuration::
  StandardMetaData (const StandardMetaData_type& x)
  {
    this->StandardMetaData_.set (x);
  }

  void Configuration::
  StandardMetaData (const StandardMetaData_optional& x)
  {
    this->StandardMetaData_ = x;
  }

  void Configuration::
  StandardMetaData (::std::unique_ptr< StandardMetaData_type > x)
  {
    this->StandardMetaData_.set (std::move (x));
  }

  const Configuration::CalculatedVariableGenericFormula_sequence& Configuration::
  CalculatedVariableGenericFormula () const
  {
    return this->CalculatedVariableGenericFormula_;
  }

  Configuration::CalculatedVariableGenericFormula_sequence& Configuration::
  CalculatedVariableGenericFormula ()
  {
    return this->CalculatedVariableGenericFormula_;
  }

  void Configuration::
  CalculatedVariableGenericFormula (const CalculatedVariableGenericFormula_sequence& s)
  {
    this->CalculatedVariableGenericFormula_ = s;
  }

  const Configuration::Motor_sequence& Configuration::
  Motor () const
  {
    return this->Motor_;
  }

  Configuration::Motor_sequence& Configuration::
  Motor ()
  {
    return this->Motor_;
  }

  void Configuration::
  Motor (const Motor_sequence& s)
  {
    this->Motor_ = s;
  }

  const Configuration::CalculatedVariable_sequence& Configuration::
  CalculatedVariable () const
  {
    return this->CalculatedVariable_;
  }

  Configuration::CalculatedVariable_sequence& Configuration::
  CalculatedVariable ()
  {
    return this->CalculatedVariable_;
  }

  void Configuration::
  CalculatedVariable (const CalculatedVariable_sequence& s)
  {
    this->CalculatedVariable_ = s;
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace Configuration
{
  // StandardMetaData
  //

  StandardMetaData::
  StandardMetaData ()
  : ::xml_schema::type (),
    Quasar_ (this),
    Log_ (this),
    SourceVariableThreadPool_ (this),
    Server_ (this)
  {
  }

  StandardMetaData::
  StandardMetaData (const StandardMetaData& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Quasar_ (x.Quasar_, f, this),
    Log_ (x.Log_, f, this),
    SourceVariableThreadPool_ (x.SourceVariableThreadPool_, f, this),
    Server_ (x.Server_, f, this)
  {
  }

  StandardMetaData::
  StandardMetaData (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Quasar_ (this),
    Log_ (this),
    SourceVariableThreadPool_ (this),
    Server_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void StandardMetaData::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Quasar
      //
      if (n.name () == "Quasar" && n.namespace_ () == "http://cern.ch/quasar/Configuration")
      {
        ::std::unique_ptr< Quasar_type > r (
          Quasar_traits::create (i, f, this));

        if (!this->Quasar_)
        {
          this->Quasar_.set (::std::move (r));
          continue;
        }
      }

      // Log
      //
      if (n.name () == "Log" && n.namespace_ () == "http://cern.ch/quasar/Configuration")
      {
        ::std::unique_ptr< Log_type > r (
          Log_traits::create (i, f, this));

        if (!this->Log_)
        {
          this->Log_.set (::std::move (r));
          continue;
        }
      }

      // SourceVariableThreadPool
      //
      if (n.name () == "SourceVariableThreadPool" && n.namespace_ () == "http://cern.ch/quasar/Configuration")
      {
        ::std::unique_ptr< SourceVariableThreadPool_type > r (
          SourceVariableThreadPool_traits::create (i, f, this));

        if (!this->SourceVariableThreadPool_)
        {
          this->SourceVariableThreadPool_.set (::std::move (r));
          continue;
        }
      }

      // Server
      //
      if (n.name () == "Server" && n.namespace_ () == "http://cern.ch/quasar/Configuration")
      {
        ::std::unique_ptr< Server_type > r (
          Server_traits::create (i, f, this));

        if (!this->Server_)
        {
          this->Server_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  StandardMetaData* StandardMetaData::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class StandardMetaData (*this, f, c);
  }

  StandardMetaData& StandardMetaData::
  operator= (const StandardMetaData& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Quasar_ = x.Quasar_;
      this->Log_ = x.Log_;
      this->SourceVariableThreadPool_ = x.SourceVariableThreadPool_;
      this->Server_ = x.Server_;
    }

    return *this;
  }

  StandardMetaData::
  ~StandardMetaData ()
  {
  }

  // Log
  //

  Log::
  Log ()
  : ::xml_schema::type (),
    GeneralLogLevel_ (this),
    ComponentLogLevels_ (this)
  {
  }

  Log::
  Log (const Log& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    GeneralLogLevel_ (x.GeneralLogLevel_, f, this),
    ComponentLogLevels_ (x.ComponentLogLevels_, f, this)
  {
  }

  Log::
  Log (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    GeneralLogLevel_ (this),
    ComponentLogLevels_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Log::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // GeneralLogLevel
      //
      if (n.name () == "GeneralLogLevel" && n.namespace_ () == "http://cern.ch/quasar/Configuration")
      {
        ::std::unique_ptr< GeneralLogLevel_type > r (
          GeneralLogLevel_traits::create (i, f, this));

        if (!this->GeneralLogLevel_)
        {
          this->GeneralLogLevel_.set (::std::move (r));
          continue;
        }
      }

      // ComponentLogLevels
      //
      if (n.name () == "ComponentLogLevels" && n.namespace_ () == "http://cern.ch/quasar/Configuration")
      {
        ::std::unique_ptr< ComponentLogLevels_type > r (
          ComponentLogLevels_traits::create (i, f, this));

        if (!this->ComponentLogLevels_)
        {
          this->ComponentLogLevels_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  Log* Log::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Log (*this, f, c);
  }

  Log& Log::
  operator= (const Log& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->GeneralLogLevel_ = x.GeneralLogLevel_;
      this->ComponentLogLevels_ = x.ComponentLogLevels_;
    }

    return *this;
  }

  Log::
  ~Log ()
  {
  }

  // GeneralLogLevel
  //

  GeneralLogLevel::
  GeneralLogLevel (const logLevel_type& logLevel)
  : ::xml_schema::type (),
    logLevel_ (logLevel, this)
  {
  }

  GeneralLogLevel::
  GeneralLogLevel (const GeneralLogLevel& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    logLevel_ (x.logLevel_, f, this)
  {
  }

  GeneralLogLevel::
  GeneralLogLevel (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    logLevel_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void GeneralLogLevel::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "logLevel" && n.namespace_ ().empty ())
      {
        this->logLevel_.set (logLevel_traits::create (i, f, this));
        continue;
      }
    }

    if (!logLevel_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "logLevel",
        "");
    }
  }

  GeneralLogLevel* GeneralLogLevel::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class GeneralLogLevel (*this, f, c);
  }

  GeneralLogLevel& GeneralLogLevel::
  operator= (const GeneralLogLevel& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->logLevel_ = x.logLevel_;
    }

    return *this;
  }

  GeneralLogLevel::
  ~GeneralLogLevel ()
  {
  }

  // ComponentLogLevels
  //

  ComponentLogLevels::
  ComponentLogLevels ()
  : ::xml_schema::type (),
    ComponentLogLevel_ (this)
  {
  }

  ComponentLogLevels::
  ComponentLogLevels (const ComponentLogLevels& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ComponentLogLevel_ (x.ComponentLogLevel_, f, this)
  {
  }

  ComponentLogLevels::
  ComponentLogLevels (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ComponentLogLevel_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ComponentLogLevels::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ComponentLogLevel
      //
      if (n.name () == "ComponentLogLevel" && n.namespace_ () == "http://cern.ch/quasar/Configuration")
      {
        ::std::unique_ptr< ComponentLogLevel_type > r (
          ComponentLogLevel_traits::create (i, f, this));

        this->ComponentLogLevel_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  ComponentLogLevels* ComponentLogLevels::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ComponentLogLevels (*this, f, c);
  }

  ComponentLogLevels& ComponentLogLevels::
  operator= (const ComponentLogLevels& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->ComponentLogLevel_ = x.ComponentLogLevel_;
    }

    return *this;
  }

  ComponentLogLevels::
  ~ComponentLogLevels ()
  {
  }

  // ComponentLogLevel
  //

  ComponentLogLevel::
  ComponentLogLevel (const componentName_type& componentName,
                     const logLevel_type& logLevel)
  : ::xml_schema::type (),
    componentName_ (componentName, this),
    logLevel_ (logLevel, this)
  {
  }

  ComponentLogLevel::
  ComponentLogLevel (const ComponentLogLevel& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    componentName_ (x.componentName_, f, this),
    logLevel_ (x.logLevel_, f, this)
  {
  }

  ComponentLogLevel::
  ComponentLogLevel (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    componentName_ (this),
    logLevel_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void ComponentLogLevel::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "componentName" && n.namespace_ ().empty ())
      {
        this->componentName_.set (componentName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "logLevel" && n.namespace_ ().empty ())
      {
        this->logLevel_.set (logLevel_traits::create (i, f, this));
        continue;
      }
    }

    if (!componentName_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "componentName",
        "");
    }

    if (!logLevel_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "logLevel",
        "");
    }
  }

  ComponentLogLevel* ComponentLogLevel::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ComponentLogLevel (*this, f, c);
  }

  ComponentLogLevel& ComponentLogLevel::
  operator= (const ComponentLogLevel& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->componentName_ = x.componentName_;
      this->logLevel_ = x.logLevel_;
    }

    return *this;
  }

  ComponentLogLevel::
  ~ComponentLogLevel ()
  {
  }

  // SourceVariableThreadPool
  //

  SourceVariableThreadPool::
  SourceVariableThreadPool (const minThreads_type& minThreads,
                            const maxThreads_type& maxThreads,
                            const maxJobs_type& maxJobs)
  : ::xml_schema::type (),
    minThreads_ (minThreads, this),
    maxThreads_ (maxThreads, this),
    maxJobs_ (maxJobs, this)
  {
  }

  SourceVariableThreadPool::
  SourceVariableThreadPool (const SourceVariableThreadPool& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    minThreads_ (x.minThreads_, f, this),
    maxThreads_ (x.maxThreads_, f, this),
    maxJobs_ (x.maxJobs_, f, this)
  {
  }

  SourceVariableThreadPool::
  SourceVariableThreadPool (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    minThreads_ (this),
    maxThreads_ (this),
    maxJobs_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void SourceVariableThreadPool::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "minThreads" && n.namespace_ ().empty ())
      {
        this->minThreads_.set (minThreads_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "maxThreads" && n.namespace_ ().empty ())
      {
        this->maxThreads_.set (maxThreads_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "maxJobs" && n.namespace_ ().empty ())
      {
        this->maxJobs_.set (maxJobs_traits::create (i, f, this));
        continue;
      }
    }

    if (!minThreads_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "minThreads",
        "");
    }

    if (!maxThreads_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "maxThreads",
        "");
    }

    if (!maxJobs_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "maxJobs",
        "");
    }
  }

  SourceVariableThreadPool* SourceVariableThreadPool::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SourceVariableThreadPool (*this, f, c);
  }

  SourceVariableThreadPool& SourceVariableThreadPool::
  operator= (const SourceVariableThreadPool& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->minThreads_ = x.minThreads_;
      this->maxThreads_ = x.maxThreads_;
      this->maxJobs_ = x.maxJobs_;
    }

    return *this;
  }

  SourceVariableThreadPool::
  ~SourceVariableThreadPool ()
  {
  }

  // logLevelIdentifier
  //

  logLevelIdentifier::
  logLevelIdentifier (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_logLevelIdentifier_convert ();
  }

  logLevelIdentifier::
  logLevelIdentifier (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_logLevelIdentifier_convert ();
  }

  logLevelIdentifier::
  logLevelIdentifier (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_logLevelIdentifier_convert ();
  }

  logLevelIdentifier* logLevelIdentifier::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class logLevelIdentifier (*this, f, c);
  }

  logLevelIdentifier::value logLevelIdentifier::
  _xsd_logLevelIdentifier_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_logLevelIdentifier_literals_);
    const value* i (::std::lower_bound (
                      _xsd_logLevelIdentifier_indexes_,
                      _xsd_logLevelIdentifier_indexes_ + 5,
                      *this,
                      c));

    if (i == _xsd_logLevelIdentifier_indexes_ + 5 || _xsd_logLevelIdentifier_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const logLevelIdentifier::
  _xsd_logLevelIdentifier_literals_[5] =
  {
    "ERR",
    "WRN",
    "INF",
    "DBG",
    "TRC"
  };

  const logLevelIdentifier::value logLevelIdentifier::
  _xsd_logLevelIdentifier_indexes_[5] =
  {
    ::Configuration::logLevelIdentifier::DBG,
    ::Configuration::logLevelIdentifier::ERR,
    ::Configuration::logLevelIdentifier::INF,
    ::Configuration::logLevelIdentifier::TRC,
    ::Configuration::logLevelIdentifier::WRN
  };

  // Quasar
  //

  Quasar::
  Quasar ()
  : ::xml_schema::type ()
  {
  }

  Quasar::
  Quasar (const Quasar& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c)
  {
  }

  Quasar::
  Quasar (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f, c)
  {
  }

  Quasar::
  Quasar (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (a, f, c)
  {
  }

  Quasar::
  Quasar (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (s, e, f, c)
  {
  }

  Quasar* Quasar::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Quasar (*this, f, c);
  }

  Quasar::
  ~Quasar ()
  {
  }

  // Server
  //

  Server::
  Server ()
  : ::xml_schema::type ()
  {
  }

  Server::
  Server (const Server& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c)
  {
  }

  Server::
  Server (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f, c)
  {
  }

  Server::
  Server (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (a, f, c)
  {
  }

  Server::
  Server (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (s, e, f, c)
  {
  }

  Server* Server::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Server (*this, f, c);
  }

  Server::
  ~Server ()
  {
  }

  // ObjectName
  //

  ObjectName::
  ObjectName ()
  : ::xml_schema::string ()
  {
  }

  ObjectName::
  ObjectName (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  ObjectName::
  ObjectName (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  ObjectName::
  ObjectName (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  ObjectName::
  ObjectName (const ObjectName& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  ObjectName::
  ObjectName (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  ObjectName::
  ObjectName (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  ObjectName::
  ObjectName (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  ObjectName* ObjectName::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ObjectName (*this, f, c);
  }

  ObjectName::
  ~ObjectName ()
  {
  }

  // CalculatedVariable
  //

  CalculatedVariable::
  CalculatedVariable (const name_type& name,
                      const value_type& value)
  : ::xml_schema::type (),
    name_ (name, this),
    value_ (value, this),
    initialValue_ (this),
    isBoolean_ (isBoolean_default_value (), this),
    status_ (this)
  {
  }

  CalculatedVariable::
  CalculatedVariable (const CalculatedVariable& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    name_ (x.name_, f, this),
    value_ (x.value_, f, this),
    initialValue_ (x.initialValue_, f, this),
    isBoolean_ (x.isBoolean_, f, this),
    status_ (x.status_, f, this)
  {
  }

  CalculatedVariable::
  CalculatedVariable (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    name_ (this),
    value_ (this),
    initialValue_ (this),
    isBoolean_ (this),
    status_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void CalculatedVariable::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "initialValue" && n.namespace_ ().empty ())
      {
        this->initialValue_.set (initialValue_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isBoolean" && n.namespace_ ().empty ())
      {
        this->isBoolean_.set (isBoolean_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "status" && n.namespace_ ().empty ())
      {
        this->status_.set (status_traits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }

    if (!isBoolean_.present ())
    {
      this->isBoolean_.set (isBoolean_default_value ());
    }
  }

  CalculatedVariable* CalculatedVariable::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CalculatedVariable (*this, f, c);
  }

  CalculatedVariable& CalculatedVariable::
  operator= (const CalculatedVariable& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->name_ = x.name_;
      this->value_ = x.value_;
      this->initialValue_ = x.initialValue_;
      this->isBoolean_ = x.isBoolean_;
      this->status_ = x.status_;
    }

    return *this;
  }

  CalculatedVariable::
  ~CalculatedVariable ()
  {
  }

  // CalculatedVariableGenericFormula
  //

  CalculatedVariableGenericFormula::
  CalculatedVariableGenericFormula (const name_type& name,
                                    const formula_type& formula)
  : ::xml_schema::type (),
    name_ (name, this),
    formula_ (formula, this)
  {
  }

  CalculatedVariableGenericFormula::
  CalculatedVariableGenericFormula (const CalculatedVariableGenericFormula& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    name_ (x.name_, f, this),
    formula_ (x.formula_, f, this)
  {
  }

  CalculatedVariableGenericFormula::
  CalculatedVariableGenericFormula (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    name_ (this),
    formula_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void CalculatedVariableGenericFormula::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "formula" && n.namespace_ ().empty ())
      {
        this->formula_.set (formula_traits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!formula_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "formula",
        "");
    }
  }

  CalculatedVariableGenericFormula* CalculatedVariableGenericFormula::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CalculatedVariableGenericFormula (*this, f, c);
  }

  CalculatedVariableGenericFormula& CalculatedVariableGenericFormula::
  operator= (const CalculatedVariableGenericFormula& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->name_ = x.name_;
      this->formula_ = x.formula_;
    }

    return *this;
  }

  CalculatedVariableGenericFormula::
  ~CalculatedVariableGenericFormula ()
  {
  }

  // Motor
  //

  Motor::
  Motor (const name_type& name)
  : ::xml_schema::type (),
    CalculatedVariable_ (this),
    name_ (name, this)
  {
  }

  Motor::
  Motor (const Motor& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    CalculatedVariable_ (x.CalculatedVariable_, f, this),
    name_ (x.name_, f, this)
  {
  }

  Motor::
  Motor (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    CalculatedVariable_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Motor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // CalculatedVariable
      //
      if (n.name () == "CalculatedVariable" && n.namespace_ () == "http://cern.ch/quasar/Configuration")
      {
        ::std::unique_ptr< CalculatedVariable_type > r (
          CalculatedVariable_traits::create (i, f, this));

        this->CalculatedVariable_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  Motor* Motor::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Motor (*this, f, c);
  }

  Motor& Motor::
  operator= (const Motor& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->CalculatedVariable_ = x.CalculatedVariable_;
      this->name_ = x.name_;
    }

    return *this;
  }

  Motor::
  ~Motor ()
  {
  }

  // Configuration
  //

  Configuration::
  Configuration ()
  : ::xml_schema::type (),
    StandardMetaData_ (this),
    CalculatedVariableGenericFormula_ (this),
    Motor_ (this),
    CalculatedVariable_ (this)
  {
  }

  Configuration::
  Configuration (const Configuration& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    StandardMetaData_ (x.StandardMetaData_, f, this),
    CalculatedVariableGenericFormula_ (x.CalculatedVariableGenericFormula_, f, this),
    Motor_ (x.Motor_, f, this),
    CalculatedVariable_ (x.CalculatedVariable_, f, this)
  {
  }

  Configuration::
  Configuration (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    StandardMetaData_ (this),
    CalculatedVariableGenericFormula_ (this),
    Motor_ (this),
    CalculatedVariable_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Configuration::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // StandardMetaData
      //
      if (n.name () == "StandardMetaData" && n.namespace_ () == "http://cern.ch/quasar/Configuration")
      {
        ::std::unique_ptr< StandardMetaData_type > r (
          StandardMetaData_traits::create (i, f, this));

        if (!this->StandardMetaData_)
        {
          this->StandardMetaData_.set (::std::move (r));
          continue;
        }
      }

      // CalculatedVariableGenericFormula
      //
      if (n.name () == "CalculatedVariableGenericFormula" && n.namespace_ () == "http://cern.ch/quasar/Configuration")
      {
        ::std::unique_ptr< CalculatedVariableGenericFormula_type > r (
          CalculatedVariableGenericFormula_traits::create (i, f, this));

        this->CalculatedVariableGenericFormula_.push_back (::std::move (r));
        continue;
      }

      // Motor
      //
      if (n.name () == "Motor" && n.namespace_ () == "http://cern.ch/quasar/Configuration")
      {
        ::std::unique_ptr< Motor_type > r (
          Motor_traits::create (i, f, this));

        this->Motor_.push_back (::std::move (r));
        continue;
      }

      // CalculatedVariable
      //
      if (n.name () == "CalculatedVariable" && n.namespace_ () == "http://cern.ch/quasar/Configuration")
      {
        ::std::unique_ptr< CalculatedVariable_type > r (
          CalculatedVariable_traits::create (i, f, this));

        this->CalculatedVariable_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  Configuration* Configuration::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Configuration (*this, f, c);
  }

  Configuration& Configuration::
  operator= (const Configuration& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->StandardMetaData_ = x.StandardMetaData_;
      this->CalculatedVariableGenericFormula_ = x.CalculatedVariableGenericFormula_;
      this->Motor_ = x.Motor_;
      this->CalculatedVariable_ = x.CalculatedVariable_;
    }

    return *this;
  }

  Configuration::
  ~Configuration ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace Configuration
{
  ::std::unique_ptr< ::Configuration::Configuration >
  configuration (const ::std::string& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::Configuration::Configuration > (
      ::Configuration::configuration (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Configuration::Configuration >
  configuration (const ::std::string& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::Configuration::Configuration > (
      ::Configuration::configuration (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Configuration::Configuration >
  configuration (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::Configuration::Configuration > (
      ::Configuration::configuration (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Configuration::Configuration >
  configuration (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::Configuration::configuration (isrc, f, p);
  }

  ::std::unique_ptr< ::Configuration::Configuration >
  configuration (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::Configuration::configuration (isrc, h, f, p);
  }

  ::std::unique_ptr< ::Configuration::Configuration >
  configuration (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::Configuration::configuration (isrc, h, f, p);
  }

  ::std::unique_ptr< ::Configuration::Configuration >
  configuration (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::Configuration::configuration (isrc, f, p);
  }

  ::std::unique_ptr< ::Configuration::Configuration >
  configuration (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::Configuration::configuration (isrc, h, f, p);
  }

  ::std::unique_ptr< ::Configuration::Configuration >
  configuration (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::Configuration::configuration (isrc, h, f, p);
  }

  ::std::unique_ptr< ::Configuration::Configuration >
  configuration (::xercesc::InputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::Configuration::Configuration > (
      ::Configuration::configuration (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Configuration::Configuration >
  configuration (::xercesc::InputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::Configuration::Configuration > (
      ::Configuration::configuration (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Configuration::Configuration >
  configuration (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::Configuration::Configuration > (
      ::Configuration::configuration (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Configuration::Configuration >
  configuration (const ::xercesc::DOMDocument& doc,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::Configuration::Configuration > (
        ::Configuration::configuration (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "configuration" &&
        n.namespace_ () == "http://cern.ch/quasar/Configuration")
    {
      ::std::unique_ptr< ::Configuration::Configuration > r (
        ::xsd::cxx::tree::traits< ::Configuration::Configuration, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "configuration",
      "http://cern.ch/quasar/Configuration");
  }

  ::std::unique_ptr< ::Configuration::Configuration >
  configuration (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "configuration" &&
        n.namespace_ () == "http://cern.ch/quasar/Configuration")
    {
      ::std::unique_ptr< ::Configuration::Configuration > r (
        ::xsd::cxx::tree::traits< ::Configuration::Configuration, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "configuration",
      "http://cern.ch/quasar/Configuration");
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace Configuration
{
  void
  operator<< (::xercesc::DOMElement& e, const StandardMetaData& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Quasar
    //
    if (i.Quasar ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Quasar",
          "http://cern.ch/quasar/Configuration",
          e));

      s << *i.Quasar ();
    }

    // Log
    //
    if (i.Log ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Log",
          "http://cern.ch/quasar/Configuration",
          e));

      s << *i.Log ();
    }

    // SourceVariableThreadPool
    //
    if (i.SourceVariableThreadPool ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SourceVariableThreadPool",
          "http://cern.ch/quasar/Configuration",
          e));

      s << *i.SourceVariableThreadPool ();
    }

    // Server
    //
    if (i.Server ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Server",
          "http://cern.ch/quasar/Configuration",
          e));

      s << *i.Server ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Log& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // GeneralLogLevel
    //
    if (i.GeneralLogLevel ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "GeneralLogLevel",
          "http://cern.ch/quasar/Configuration",
          e));

      s << *i.GeneralLogLevel ();
    }

    // ComponentLogLevels
    //
    if (i.ComponentLogLevels ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ComponentLogLevels",
          "http://cern.ch/quasar/Configuration",
          e));

      s << *i.ComponentLogLevels ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GeneralLogLevel& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // logLevel
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "logLevel",
          e));

      a << i.logLevel ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ComponentLogLevels& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // ComponentLogLevel
    //
    for (ComponentLogLevels::ComponentLogLevel_const_iterator
         b (i.ComponentLogLevel ().begin ()), n (i.ComponentLogLevel ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ComponentLogLevel",
          "http://cern.ch/quasar/Configuration",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ComponentLogLevel& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // componentName
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "componentName",
          e));

      a << i.componentName ();
    }

    // logLevel
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "logLevel",
          e));

      a << i.logLevel ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SourceVariableThreadPool& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // minThreads
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "minThreads",
          e));

      a << i.minThreads ();
    }

    // maxThreads
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "maxThreads",
          e));

      a << i.maxThreads ();
    }

    // maxJobs
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "maxJobs",
          e));

      a << i.maxJobs ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const logLevelIdentifier& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const logLevelIdentifier& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const logLevelIdentifier& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Quasar& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr&, const Quasar&)
  {
  }

  void
  operator<< (::xml_schema::list_stream&,
              const Quasar&)
  {
  }

  void
  operator<< (::xercesc::DOMElement& e, const Server& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr&, const Server&)
  {
  }

  void
  operator<< (::xml_schema::list_stream&,
              const Server&)
  {
  }

  void
  operator<< (::xercesc::DOMElement& e, const ObjectName& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const ObjectName& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const ObjectName& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const CalculatedVariable& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // value
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "value",
          e));

      a << i.value ();
    }

    // initialValue
    //
    if (i.initialValue ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "initialValue",
          e));

      a << ::xml_schema::as_double(*i.initialValue ());
    }

    // isBoolean
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isBoolean",
          e));

      a << i.isBoolean ();
    }

    // status
    //
    if (i.status ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "status",
          e));

      a << *i.status ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const CalculatedVariableGenericFormula& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // formula
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formula",
          e));

      a << i.formula ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Motor& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // CalculatedVariable
    //
    for (Motor::CalculatedVariable_const_iterator
         b (i.CalculatedVariable ().begin ()), n (i.CalculatedVariable ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "CalculatedVariable",
          "http://cern.ch/quasar/Configuration",
          e));

      s << *b;
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Configuration& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // StandardMetaData
    //
    if (i.StandardMetaData ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "StandardMetaData",
          "http://cern.ch/quasar/Configuration",
          e));

      s << *i.StandardMetaData ();
    }

    // CalculatedVariableGenericFormula
    //
    for (Configuration::CalculatedVariableGenericFormula_const_iterator
         b (i.CalculatedVariableGenericFormula ().begin ()), n (i.CalculatedVariableGenericFormula ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "CalculatedVariableGenericFormula",
          "http://cern.ch/quasar/Configuration",
          e));

      s << *b;
    }

    // Motor
    //
    for (Configuration::Motor_const_iterator
         b (i.Motor ().begin ()), n (i.Motor ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Motor",
          "http://cern.ch/quasar/Configuration",
          e));

      s << *b;
    }

    // CalculatedVariable
    //
    for (Configuration::CalculatedVariable_const_iterator
         b (i.CalculatedVariable ().begin ()), n (i.CalculatedVariable ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "CalculatedVariable",
          "http://cern.ch/quasar/Configuration",
          e));

      s << *b;
    }
  }

  void
  configuration (::std::ostream& o,
                 const ::Configuration::Configuration& s,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::Configuration::configuration (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  configuration (::std::ostream& o,
                 const ::Configuration::Configuration& s,
                 ::xml_schema::error_handler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::Configuration::configuration (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  configuration (::std::ostream& o,
                 const ::Configuration::Configuration& s,
                 ::xercesc::DOMErrorHandler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::Configuration::configuration (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  configuration (::xercesc::XMLFormatTarget& t,
                 const ::Configuration::Configuration& s,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::Configuration::configuration (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  configuration (::xercesc::XMLFormatTarget& t,
                 const ::Configuration::Configuration& s,
                 ::xml_schema::error_handler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::Configuration::configuration (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  configuration (::xercesc::XMLFormatTarget& t,
                 const ::Configuration::Configuration& s,
                 ::xercesc::DOMErrorHandler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::Configuration::configuration (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  configuration (::xercesc::DOMDocument& d,
                 const ::Configuration::Configuration& s,
                 ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "configuration" &&
        n.namespace_ () == "http://cern.ch/quasar/Configuration")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "configuration",
        "http://cern.ch/quasar/Configuration");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  configuration (const ::Configuration::Configuration& s,
                 const ::xml_schema::namespace_infomap& m,
                 ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "configuration",
        "http://cern.ch/quasar/Configuration",
        m, f));

    ::Configuration::configuration (*d, s, f);
    return d;
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

